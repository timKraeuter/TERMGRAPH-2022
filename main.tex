\documentclass[submission, copyright, creativecommons]{eptcs}
\providecommand{\event}{TERMGRAPH 2022} % Name of the event you are submitting to
% \usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{underscore}           % Only needed if you use pdflatex.

% My packages
\usepackage{orcidlink} % Orcid links
\newcommand\Mark[1]{\textsuperscript#1}

\usepackage{subcaption} % Side by side figures
\usepackage{amssymb} % \square command
% Footnotes inside tables
\usepackage{footnote}
\usepackage{csquotes} % enquote command
\usepackage{glossaries} % Glossary
\usepackage{threeparttable} % Tables with notes
\makesavenoteenv{tabular}
\makesavenoteenv{table}
\usepackage[nameinlink]{cleveref} % Reference footnotes.
\crefname{figure}{{figure}}{figures}
\Crefname{figure}{{Figure}}{Figures}
\crefformat{footnote}{#2\footnotemark[#1]#3}
% Math
\newtheorem{definition}{Definition}
\newcommand{\definitionautorefname}{Definition}
% Acronyms
\newacronym{bpmn}{BPMN}{Business Process Modeling Notation}

\title{Formalization and analysis of BPMN using graph transformation systems}
\author{Tim Kräuter\Mark{*}\orcidlink{0000-0003-1795-0611}, \quad
Harald König\Mark{\textdagger}\Mark{*}\orcidlink{0000-0001-6304-6311}, \quad
Adrian Rutle\Mark{*}\orcidlink{0000-0002-4158-1644}, \quad
Yngve Lamo\Mark{*}\orcidlink{0000-0001-9196-1779}
\institute{
\Mark{*}Western Norway University of Applied Sciences, Bergen, Norway
}
\institute{
\Mark{\textdagger}University of Applied Sciences, FHDW, Hannover, Germany}
\email{tkra@hvl.no, harald.koenig@fhdw.de, aru@hvl.no, yla@hvl.no}
}
\def\titlerunning{Formalization and analysis of BPMN using graph transformation systems}
\def\authorrunning{Kräuter \textit{et al.}}
\begin{document}
\maketitle

% Maximum 8 pages for the first extended abstract(including references)!
% Maximum of 10 pages for the first revision.

\begin{abstract}
The BPMN is a widely used standard notation for defining intra- and inter-organizational workflows.
However, the informal description of the BPMN execution semantics leads to different interpretations of BPMN constructs and difficulties in checking behavioral properties.
Other approaches to formalizing BPMN’s execution semantics only partially cover BPMN.
To this end, we propose a formalization that, compared to other approaches, covers most of the BPMN constructs.
Our approach is based on a model transformation from BPMN models to graph transformation systems. 
As a proof of concept, we have implemented our approach in an open-source web-based tool.
\end{abstract}

\section{Introduction}
% Short Motivation: Formalization of the natural language semantics and model checking
\gls*{bpmn} is a widely used standard notation to define intra- and inter-organizational workflows.
However, the informal description of the BPMN execution semantics leads to different interpretations of BPMN constructs and difficulties in checking behavioral properties \cite{corradiniFormalApproachAnalysis2021, objectmanagementgroupBusinessProcessModel2013}.
To this end, we propose a formalization that, compared to other approaches, covers most of the BPMN constructs.

Our approach is depicted as a BPMN process model in \cref{fig:approach}.
It is based on a model transformation from BPMN process models to graph transformation systems.
Thus, our approach constructs a new graph transformation system, i.e., graph transformation rules and a start graph for each BPMN process model.
This is a significant difference compared to other approaches such as \cite{corradiniFormalApproachAnalysis2021, vangorpVisualTokenbasedFormalization2013}, where only the BPMN process model is parsed, but the rewrite rules are fixed.
Generating specific rules for each model leads to possibly more but simpler transformation rules that can be matched faster.
Essentially, complexity is partly shifted from the transformation rules to their generation.
The generated rules are tailored to a given process model and thus simpler than the general rules in \cite{vangorpVisualTokenbasedFormalization2013}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth]{images/full-approach.pdf}
    \caption{Overview of the proposed approach}
    \label{fig:approach}
\end{figure}

% Paper outline
The remainder of this paper is structured as follows.
First, we describe the semantics formalization using graph transformation systems (\cref{sec:formalization}) before explaining how this can be utilized for model checking BPMN-specific and custom properties (\cref{sec:modelChecking}).
Then, we shortly present the web-based tool implementing our approach.
Finally, we discuss related work regarding BPMN construct coverage in \cref{sec:relatedWork} and conclude in \cref{sec:conclusion}.

\section{Preliminaries}
% Describe the application are
In this paper, we apply graph rewriting theory to formalize the execution semantics of BPMN.
Thus, in this section, we will briefly introduce BPMN and its execution semantics.
Please refer to \cite{freundRealLifeBPMNUsing2019} or the BPMN specification \cite{objectmanagementgroupBusinessProcessModel2013} for further information about BPMN.
% Describe the applied theory.
Furthermore, we describe the theoretical background behind our application of graph rewriting.
\subsection{BPMN}
% Introduce BPMN
BPMN  is a widely used standard notation to define intra- and inter-organizational workflows.
\Cref{fig:bpmnMetamodel} depicts the structure of BPMN process models and the corresponding BPMN symbols contained in clouds.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.75\linewidth]{images/bpmn_semantics-bpmn-metamodel.pdf}
  \caption{Simplified excerpt of the BPMN metamodel \cite{objectmanagementgroupBusinessProcessModel2013}}
  \label{fig:bpmnMetamodel}
\end{figure}

A BPMN process model is represented by a \textsf{Collaboration} that has \textsf{participants} and \textsf{MessageFlows} between \textsf{InteractionNodes} (see  \cref{fig:bpmnMetamodel}).
Each participant is a \textsf{Process} containing \textsf{FlowNodes} connected by \textsf{SequenceFlows}.
A \textsf{FlowNode} is either an \textsf{Activity}, \textsf{Gateway} or \textsf{Event}.
There exist many types of \textsf{Activities}, \textsf{Gateways} and \textsf{Events} such as start and end events, for example, used in \cref{fig:approach}.
Activities represent certain tasks to be carried out during a process, while things may happen (events).
Furthermore, gateways represent conditions or split and merge sequence flows \cite{freundRealLifeBPMNUsing2019}.

% BPMN semantics: Token distribution
The BPMN execution semantics are described using the concept of \emph{tokens} \cite{objectmanagementgroupBusinessProcessModel2013}.
BPMN process models are executed by triggering one or more of their start events, leading to the creation of a token at each triggered start event.
Tokens are transported between flow nodes by sequence flows (arrows)
\footnote{The visual bpmm-js token simulation available at \url{https://bpmn-io.github.io/bpmn-js-token-simulation/modeler.html} greatly helps to understand BPMN execution semantics.}.
% Activities
Activities can start when there is at least one token located on an incoming sequence flow.
The start of an activity will move the incoming token to the activity.
When an activity finishes it will create one token for each outgoing sequence flow.
% Gateways
Different gateway types exist, for example, for split/merge or XOR/OR distribution of tokens.
% Events (basic)
Events consume and create tokens similarly to activities but also have additional semantics depending on their type.
For example, message events will create or consume messages.

\subsection{Theoretical background}
We use typed attributed graphs for the formalization of the BPMN execution semantics.
Each state, i.e., token distribution during the execution of a BPMN model is represented as an attributed graph typed in the BPMN execution type graph introduced later in \cref{sec:formalization}.

% Groove uses the single pushout approach with negative application conditions.
Regarding graph transformation, we utilize the single-pushout (SPO) approach with negative application conditions (NAC) \cite{ehrigALGEBRAICAPPROACHESGRAPH1997}.
In addition, we utilize \emph{nested rules} with quantification to make parts of a rule applied repeatedly or optionally \cite{rensinkNestedQuantificationGraph2006,rensinkHowMuchAre2017}.
SPO is sufficient to formalize the BPMN execution semantics and the automatic removal of dangling edges is not a problem.
Moreover, we utilize NACs to implement some more intricate parts in the BPMN execution semantics such as the termination of processes. 
In SPO rewriting, a graph transformation rule is defined as a partial graph morphism $L \to R$, while in our case $L$ and $R$ are typed attributed graphs. 
\section{BPMN semantics formalization} \label{sec:formalization}

Since our approach is based on a model transformation from BPMN to graph transformation systems, we generate a \emph{start graph} and \emph{graph transformation rules} for a given BPMN process model.
The approach supports the BPMN constructs depicted in \cref{fig:bpmnConstructsOverview}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.99\textwidth]{images/bpmn_semantics-feature-overview.pdf}
    \caption{Overview of the supported BPMN constructs (structure adapted from \cite{houhouFirstOrderLogicVerification2022})}
    \label{fig:bpmnConstructsOverview}
\end{figure}

Our formalization of BPMN is token-based, as in the informal description of the BPMN specification \cite{objectmanagementgroupBusinessProcessModel2013}.
Thus, to describe processes holding tokens during execution, we use the type graph shown in \cref{fig:typeGraph}.
The type graph is depicted using a UML class diagram-like syntax.

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{images/bpmn_semantics-typegraph.pdf}
  \caption{BPMN execution type graph}
  \label{fig:typeGraph}
\end{figure}

We use \textsf{ProcessSnapshot} to denote a running BPMN process with a specific token distribution which describes one state in the history of process states during the execution.
Every \textsf{ProcessSnapshot} has a set of \textsf{tokens}, incoming \textsf{messages}, and \textsf{subprocesses}.
A \textsf{ProcessSnapshot} has the state \textsf{Terminated} if it has no \textsf{tokens} or \textsf{subprocesses}.
Otherwise, it has the state \textsf{Running}.
A \textsf{Token} has an \textsf{elementID}, the BPMN activity or sequence flow at which it is located.
A \textsf{Message} has an \textsf{elementID}, pointing to a \textsf{MessageFlow}.
To depict graphs conforming to the type graph concisely, we introduce a concrete syntax in the clouds attached to the elements.
It extends the BPMN syntax by adding tokens.
Tokens are represented as colored circles and are drawn at their specified position in a model.
Their color will match the color of the circle representing the process snapshot holding the token, which is located at the top left of the corresponding BPMN process.
The concrete syntax was significantly inspired by the excellent bpmn-js-token-simulation\footnote{\url{https://github.com/bpmn-io/bpmn-js-token-simulation}}.
Using this type graph, we can now define how the start graph and graph-transformation rules for the different BPMN constructs are created.

% How is a start graph generated?
The generation of the start graph for a BPMN model is straightforward.
For each process in the BPMN model, we generate a process snapshot if the process contains a none start event (NSE).
Then, for each NSE, we add a token to the respective process snapshot.
An example of a start graph is shown in \cref{fig:startGraph} using abstract and concrete syntax.
Furthermore, we consider allowing the user to define a start graph similar to how he can define atomic propositions for custom properties (see \cref{subsec:customProperties}).

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{images/startGraph.pdf}
    \caption{Example start graph in abstract (left) and concrete syntax (right)}
    \label{fig:startGraph}
\end{figure}

The model transformation generates one or more graph transformation rules for each \textsf{FlowNode} in a BPMN model.
We will now describe the rule generation for NSE's, tasks, and message events to give an overview of how our model transformation works.
A table summarizing how the model transformation works for the main \textsf{FlowNodes} is contained in the artifacts of this paper \cite{timkrauterArtifactsTERMGRAPH2022}.
\Cref{fig:gtRuleAbstract} depicts an example graph transformation rule ($L \to R$) for a NSE in abstract syntax.
The rule is straightforward and moves a token from the start event to its outgoing sequence flow.
For the rest of the paper, we will depict all rules in the concrete syntax introduced earlier.
The rule from \cref{fig:gtRuleAbstract} depicted in concrete syntax is shown in \cref{fig:gtRuleConcrete}.

\begin{figure}[h]
    \centering
  \includegraphics[width=0.8\textwidth]{images/rule_abstract.pdf}
  \caption{Example graph transformation rule for a NSE (abstract syntax)}  \label{fig:gtRuleAbstract}
\end{figure}

\begin{figure}[h]
    \centering
  \includegraphics[width=0.6\textwidth]{images/rule_concrete.pdf}
  \caption{Example graph transformation rule for a NSE (concrete syntax)}
  \label{fig:gtRuleConcrete}
\end{figure}

The rule in \cref{fig:taskRules} represents the start of the task, which will move one token from the incoming sequence flow to the task itself.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{images/bpmn_semantics-rules.pdf}
    \caption{Example graph transformation rule to start a task}
    \label{fig:taskRules}
\end{figure}

The left rule in \cref{fig:messageEventRules} realizes a message throw event, and the right rule implements a message catch event.
The message catch event rule consumes a token and a message and creates an outgoing token.
The message throw event rule moves the token through the event and sends a message to a waiting process snapshot, which must have a token waiting at the corresponding message receive event.
However, sending this message is optional, which is implemented using a nested rule with quantification.
Concretely, we use an optional existential quantifier to send a message only if the receiving process is ready to receive it \cite{rensinkNestedQuantificationGraph2006}.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/bpmn_semantics-message-events.pdf}
    \caption{Rules for message intermediate throw events (left) and catch events (right)}
    \label{fig:messageEventRules}
\end{figure}

End events consume but do not produce tokens.
Thus, process termination can be implemented using a general rule applicable to all process snapshots.
The rule is automatically generated once during the model transformation to graph transformation systems and is used to terminate processes, sub processes, and event sub processes.
It uses negative-application conditions to forbid tokens and sub processes for a process snapshot and then changes its state from running to terminated\footnote{The terminate rule implemented in Groove is contained in the artifacts of this paper \cite{timkrauterArtifactsTERMGRAPH2022}.}.

% TODO: make it flow with the part before. Remove the part before since we know explain things in detail?
% Make the part before highlight we generate a start graph and a set of rules depending on the flow nodes as described now:

\subsection{Process instantiation and termination}
% Start and End Event + General termination rule. + Refer to start graph.
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/start_end_template.pdf}
    \caption{Rule generation templates for start and end events}
    \label{fig:StartAndEndTemplate}
\end{figure}
% Receive tasks instantiation (low priority)
% Exclusive event based gateway instantiation (low priority)
\subsection{Activities}
% Normal activities
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/activities_template.pdf}
    \caption{Rule generation template for activities}
    \label{fig:ActivityTemplates}
\end{figure}
% Send/Receive tasks
% Sub processes
\subsection{Gateways}
% Exclusive --> Exception no incoming flows in sub processes (token taken from gateway directly)
% Parallel
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/gateways_template.pdf}
    \caption{Rule generation template for gateways}
    \label{fig:GatewayTemplates}
\end{figure}
% Event-based with different event combinations
% Mention unsupported types?
\subsection{Events}
% Message
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/event_templates.pdf}
    \caption{Rule generation template for message events}
    \label{fig:EventTemplates}
\end{figure}
% Signal
% Link
% Terminate end
% Boundary events
% Event subprocesses?

\section{Model checking BPMN} \label{sec:modelChecking}

Model checking a BPMN process model is possible using the generated graph transformation system.
Besides a graph transformation system, a set of temporal properties to be checked and the atomic propositions used in the properties must be supplied (see \cref{fig:approach}).
An atomic proposition can be formalized as a graph and holds in a given state if it is a subgraph of the graph representing the state.
This enables model checking of temporal properties, for example, LTL properties, using the defined atomic propositions.

Like other work, we differentiate between \emph{BPMN-specific properties} defined generally for all BPMN process models and \emph{custom properties} tailored towards a particular BPMN process model.
We do not consider structural properties since they can be checked using a standard process modeling tool without implementing execution semantics.
We will now give an example of two predefined BPMN-specific properties and how they can be checked using our approach.
Then, we describe how custom properties can be constructed and checked.

\subsection{BPMN-specific properties}
Two BPMN-specific behavioral properties, namely, Safeness and Soundness, are defined in \cite{corradiniClassificationBPMNCollaborations2018}.
A BPMN process model is \emph{safe} if, during its execution, at most one token occurs along the same sequence flow \cite{corradiniClassificationBPMNCollaborations2018}.
Soundness is further decomposed into (i) \emph{Option to complete}: any running process instance must eventually complete, (ii) \emph{Proper completion}: at the moment of completion, each token of the process instance must be in a different end event, (iii) \emph{No dead activities}: any activity can be executed in at least one process instance \cite{corradiniClassificationBPMNCollaborations2018}.
As an example, we will now describe how to implement the \emph{Safeness} and \emph{Option to complete} properties.

% Safeness
\emph{Safeness} is checked using the LTL property defined in \eqref{eq:safeness}.
The atomic property \textsf{Unsafe} is true if two tokens of one process snapshot have the same position\footnote{\label{footnote:atomicProps}Groove rules for the atomic properties \textsf{Unsafe} and \textsf{AllTerminated} are contained in the artifacts of this paper \cite{timkrauterArtifactsTERMGRAPH2022}.}.
% Option to complete
\emph{Option to complete} is checked using the LTL property defined in \eqref{eq:optionToComplete}.
The atomic property \textsf{AllTerminated} is true if there exists no process snapshot in the state \textsf{Running}, i.e., all process snapshots are \textsf{Terminated}\cref{footnote:atomicProps}.

\noindent\begin{minipage}{.5\linewidth}
\begin{equation} \label{eq:safeness}
  \square (\neg \,\text{Unsafe})
\end{equation}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{equation} \label{eq:optionToComplete}
  \lozenge ( \square(\text{AllTerminated})) 
\end{equation}
\end{minipage}
\vskip.3\baselineskip

Both properties can be checked using our implementation \cite{timkrauterArtifactsTERMGRAPH2022}.
To fully check Soundness, we need to check \textit{Proper Completion} and \textit{No Dead Activities}.
The information needed to check these properties is present in the generated state space.

\subsection{Custom properties} \label{subsec:customProperties}
% Defining atomic propositions in BPMN is a novelty.
To make model checking user-friendly, we envision users defining atomic propositions in the extended BPMN syntax, i.e., the concrete syntax introduced earlier.
Thus, to define an atomic proposition, we let the user attach tokens to a BPMN process model, which we can automatically convert to a graph representing an atomic proposition.

For example, the token distribution shown in \cref{fig:atomicProposition} defines two running process snapshots with a token in task A.
Differently colored tokens define different process snapshots.
A user could use this property, for example, to check if, eventually, two processes are executing task A simultaneously.
Thus, a user need not be aware of the graph transformation semantics used for execution, which is a significant advantage compared to other approaches.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{images/bpmn_semantics-atomic-proposition.pdf}
    \caption{Token distribution defining an atomic proposition.}
    \label{fig:atomicProposition}
\end{figure}

\section{Implementation} \label{sec:impl}
% Tool
\Cref{fig:implScreenshot} depicts a screenshot of the implemented tool.
The tool is open-source, publicly available, and does not require any installation \cite{timkrauterArtifactsTERMGRAPH2022}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{images/impl.png}
    \caption{Screenshot of the tool}
    \label{fig:implScreenshot}
\end{figure}

The first two steps of our approach, i.e., reading and transforming BPMN models to graph transformation systems, are implemented and usable through the web-based tool.
Then one can use the graph-transformation tool Groove\footnote{\url{https://groove.ewi.utwente.nl/about}} for state space generation and model checking locally.
We are currently working on extending our tool such that model-checking can be done without installing Groove locally.
Groove implements SPO with NACs and thus has all the features we need.
% Evaluation
To evaluate the correctness of our implementation, we created a comprehensive test suite, which demonstrates correct rule generation for the implemented BPMN constructs \cite{timkrauterArtifactsTERMGRAPH2022}.

\section{Related work} \label{sec:relatedWork}
% Van gorp
A BPMN formalization based on in-place graph transformation rules is given in \cite{vangorpVisualTokenbasedFormalization2013}.
The formalization covers a substantial part of the BPMN specification, including complex concepts such as inclusive gateway merge and compensation.
In addition, graph transformation rules are visual and thus can easily be matched to the informal description of the execution semantics in the specification \cite{objectmanagementgroupBusinessProcessModel2013}.
The graph transformation rules were implemented in a prototype using GrGen.NET.
Unfortunately, the implementation is not publicly accessible anymore.
Moreover, they do not support model checking since their goal is only formalization.

% BProve/Corradini
The tool BProVe\footnote{\url{http://pros.unicam.it/bprove/}} is based on formal BPMN semantics given in rewriting logic and implemented in the Maude system.
Using these semantics, BProVe enables the verification of custom LTL properties and BPMN-specific properties, such as Safeness and Soundness.
Furthermore, the tool is accessible online, not requiring any installation \cite{corradiniFormalApproachAnalysis2021}.

% fbpmn/Houhou
The verification framework \textsf{fbpmn} uses first-order logic to formalize and check BPMN process models \cite{houhouFirstOrderLogicVerification2022}.
This formalization is then realized in the TLA\textsuperscript{+} formal language and can be model-checked using TLC.
Their framework and related information is open source and freely available online\footnote{\url{https://github.com/pascalpoizat/fbpmn}}.
Similar to BProVe, \textsf{fbpmn} allows checking BPMN-specific properties, such as Safeness and Soundness.
However, they do not allow a user to define custom temporal properties.

We looked in detail at these three approaches since they support a significant subset of the BPMN constructs and have accessible and well-documented tools.
Nevertheless, each approach supports a different subset of the BPMN constructs.
The coverage of BPMN constructs greatly impacts how useful each approach is in practice.
\Cref{tab:supportedconstructs} depicts which BPMN constructs are supported by the different approaches compared to our approach.

\begin{table}[htbp]
    \caption{Constructs supported by different BPMN formalizations (overview based on \cite{vangorpVisualTokenbasedFormalization2013}).}
    \label{tab:supportedconstructs}
    \begin{threeparttable}
    \begin{tabular}{l l l l l}
    \hline
      Feature & Van Gorp &  Corradini & Houhou & This\\
      & et al. \cite{vangorpVisualTokenbasedFormalization2013} & et al. \cite{corradiniFormalApproachAnalysis2021}& et al. \cite{houhouFirstOrderLogicVerification2022} & paper\\
      \hline
      \textit{Instantiation and termination} & &\\
      Start event instantiation & X & X & X & X\\
      Exclusive event-based gateway instantiation & X & & & X\\
      Parallel event-based gateway instantiation &  & & & \\
      Receive task instantiation & & & & X\\
      Normal process completion & X & X & X & X\\
      \textit{Activities} & & & &\\
      Activity & X & X & X & X\\
      Subprocess & X & & X & X\\
      Ad-hoc subprocesses & & & &\\
      Loop activity & X & & &\\
      Multiple instance activity & & & & \\
      \textit{Gateways} & & & &\\
      Parallel gateway & X & X & X & X\\
      Exclusive gateway & X & X & X & X\\
      Inclusive gateway (split) & X & X & X & X\\
      Inclusive gateway (merge) & X & & X & X\\
      Event-based gateway &  & X\tnote{1} & X & X\\ % No timer and conditional events after event based gateway supported.
      Complex gateway & & & &\\
      \textit{Events} & & & & \\
      None Events & X & X & X & X\\
      Message events & X & X & X & X\\
      Timer Events & & & X & \\
      Escalation Events & & & & \\
      Error Events (catch) & X & & &\\
      Error Events (throw) & X & & &\\
      Cancel Events & X & & &\\
      Compensation Events & X & & &\\
      Conditional Events & & & &\\
      Link Events & X & & & X\\
      Signal Events & X & & & X\\
      Multiple Events &  & & & \\
      Terminate Events & X & X & X & X\\
     Boundary Events & X\tnote{2} & & X\tnote{3} & X\\ % To the same extent as the event support
      Event subprocess &  &  &  & X\\
    \end{tabular}
    \begin{tablenotes}
        \item[1] Does not support receive tasks after event-based gateways.
        \item[2] Only supports interrupting boundary events on tasks.
        \item[3] Only supports message and timer events.
    \end{tablenotes}
    \end{threeparttable}
\end{table}

% Summarize the findings and explain them in more detail
% Explain Van Gorp in detail
Van Gorp et al. \cite{vangorpVisualTokenbasedFormalization2013} cover a large part of the BPMN semantics.
However, they do not support Event-based gateways and event subprocesses, while their support for boundary events is minimal.
Especially, Event-based gateways are often used in practice.
% Explain Corradini in detail
Corradini et al. \cite{corradiniFormalApproachAnalysis2021} support message and terminate events.
% Explain Houhou in detail
In addition to \cite{corradiniFormalApproachAnalysis2021}, Houhou et al. \cite{houhouFirstOrderLogicVerification2022} support timer and the use of message and timer events as both interrupting and non-interrupting boundary events.
However, many other event types exist and are used in practice.

Referring to \cref{tab:supportedconstructs}, we conclude that our formalization is comprehensive but still lacks support for some of the more advanced event types.
An implementation of the missing event types is feasible, as shown in \cite{vangorpVisualTokenbasedFormalization2013}.

\section{Conclusion \& future work} \label{sec:conclusion}
% Summary
The approach presented in this paper utilizes a model transformation from BPMN models to graph transformation systems. 
For each BPMN model, we automatically generate a start graph and a set of graph transformation rules.
In this way, the graph transformation rules get simpler while the complexity is shifted to the model transformation from BPMN to graph transformation systems.
% Formalization & model checking
Our resulting BPMN formalization is comprehensive and supports model checking.
% Tool
In addition, we provide a prototype implementation in a web-based tool to make our ideas easily accessible to other researchers and potentially practitioners in the future.

% Future work
We aim to improve our formalization and resulting tool in multiple ways in the future.
% More semantics
First, we intend to extend our formalization to support even more BPMN constructs, for example, error, cancel, and compensation events.
% Proper evaluation
Second, we plan to evaluate our approach on models from open repositories such as the \enquote{BPM Academic Initiative Model Collection} \cite{weskeModelCollectionBusiness2020} and  \enquote{Camunda BPMN for
Research}\footnote{\url{https://github.com/camunda/bpmn-for-research}}.
% Implementing the atomic proposition definition
Third, we want to extend the features of our tool;
one should be able to define atomic propositions for model checking in the tool directly, as described in \cref{sec:modelChecking}.
% Counterexample simulation like Houhou
Furthermore, counterexamples found during model checking should be visualized directly in the tool, like the implementation in \cite{houhouFirstOrderLogicVerification2022}, such that users need not understand the underlying implementation in Groove.
\bibliographystyle{eptcs}
\bibliography{bib}
\end{document}
